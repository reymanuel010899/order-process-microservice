

------------ RUN THE PROJECT  -----------

- clone the repository
- cd order-process-microservice
- python3 -m venv venv 
- pip install -r requirements.txt -
- uvicorn app.main:app --reload

------------ SERVERLESS ARCHITECTURE ON AWS -----------

-  First let's do the business logic in lambda, we can create three lambda functions or just one and modulate them and handle the requests by method, if patch comes do this logic, if post comes do this other logic or if get comes do this other logic, from my experience I would prefer to create three lambdas for two reasons, one is super cheap, if I'm not mistaken aws gives us 1 million requests per month and then starts billing and the other reason is that I really like to have everything well segmented and clear, this way we achieve that both the infrastructure and the software are scalable.


- We use the API GATEWAY - RESTful API service. We can use both HTTP and RESTful APIs. In this case, I prefer the RESTful API since it's more robust, has more options, and is more secure. We can sign URLs since we'll be sending logs to S3. We can pass in headers and the necessary configurations. With these routes created, we point to the Lambda functions we created or to the lambda function that we created.


- Now that we have the API gateway connected correctly with Lambda, its IAM roles configured correctly, and everything, the flow will be: API Gateway gives us a URL. Every time we create an order, this POST request calls a Lambda. What will we do in the Lambda? From my experience, I would enqueue this order and use another Lambda function to process it. So, no matter what happens, we wouldn't lose an order since it would be queued. The Lambda function that processes the order would add an SQS dead message queue with 3 attempts. If it fails these 3 times when processing the order, I would send it to an S3 bucket to then analyze the cause of its failure. Or I would orchestrate a data flow with Kinesis in real time so that in real time I would let the user know what caused their order to fail.

- Lambda will have the business logic, from Lambda we connect to MongoDB, we could deploy a cluster in MongoDB Atlas so that the data is replicated in multiple tables in different regions for high availability, we could use AWS WAF for protection against SQL injection attacks at layer 7 of the OSI model, also use AWS Shield Standard for more security and to prevent DDos attacks, it works at both layer 4 and 7, I would try to manage good security, in AWS security is one of the pillars of AWS, encryption in transit with SSL / TLS to encrypt the API, at rest to encrypt data in MongoDB with KMS and automatic rotation every 90 days

- Another architecture is to use an ALB that points to the Lambda functions. Use the ALB roles if we want to communicate microservices or target different target groups that have Lambda functions as objectives. When you enter /order or /purchase, the truth is that there are a million ways to have a scalable architecture with low latency, with failover as a minimum RPO and RTO, and if I continue I will not finish today, I am very passionate about software architecture and all that, services like ecs, eks, cloudFormation, ci / cd, dns services with route53 with the type of latency routing, to bring the end user the best experience with a low latency of milliseconds, thanks that's all for now
